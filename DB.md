# This document aims to provide an overview of the database structure to facilitate data analysis

## Introduction

The database is PostgreSQL. The choice of an SQL database vs a NoSQL one like MongoDB was made for the following main reasons:
- SQL databases enforce data integrity constraints that NoSQL databases do not, thus avoiding many programming mistakes
- storing the data in normalized form allows for a more efficient storage of the data and less resources consumption
- complex queries are efficient even on modest hardware and are easy to write (the latest point may be a matter of personal taste)

Most tables have a `created_at` and `updated_at` field, which represent the time of creation and latest update of the record.
Records are rarely updated so in most cases `updated_at` will be the same as `created_at`.

There is no timezone associated with the timestamps, they are all populated with `Date.now()` javascript calls, so UTC is assumed and the various interfaces should convert the timestamps to the user's timezone.

All records have a unique `id` field, which is an UUID generated by the database.

Some values are stored as enums, for storage efficiency and to enforce data correctness.

The different values of all the enum types can be listed using the following query:

```sql
select n.nspname as enum_schema,
       t.typname as enum_name,
       e.enumlabel as enum_value
from pg_type t
   inner join pg_enum e on t.oid = e.enumtypid
   inner join pg_catalog.pg_namespace n ON n.oid = t.typnamespace;
```

## Database structure

I will briefly describe each table's main fields and purpose, for more details you can explore the tables via the [web interface](https://ytdpnl-db.fmdj.fr).

### The `migrations` table

This table is not used by the business logic of the application, its purpose is to keep track of the database migrations that have been applied
so that when the schema changes in the code, the database is updated accordingly. This prevents the server code for running with a database that is not how it expects it to be.

### The `admin` table

This table contains the list of administrators of the application. It is used to grant access to the [web interface](https://ytdpnl.fmdj.fr).
The most important fields are:
- `name`
- `email`
- `password` (hashed with bcrypt, so it is not possible to retrieve the original password and the hash itself is of no value to an attacker)

### The `token` table

The [web interface](https://ytdpnl.fmdj.fr) uses a token-based authentication system (no cookies, safer). This table contains the list of tokens that have been generated by the application for administrators. A token is valid for one hour and needs to be [passed to the API](https://github.com/djfm/ytdpnl-server/blob/main/src/server-app/adminApi.ts) using the `authorization` header.

Participants do not need a token to access the API routes that they are allowed to access. The [API client](https://github.com/djfm/ytdpnl-extension/blob/main/src/api.ts) just passes the participant's code using the `x-participant-code` header.

### The `participant` table

This table contains the list of participants to the experiment.
The most important fields are:
- `email`
- `code` (the code that the participants will input in the extension's setup form to identify themselves)
- `arm` (the experiment arm, either `control` or `treatment`), stored as an enum so that invalid values cannot be input

### The `experiment_config` table

This table contains the configuration of the experiment. It is used to set the experiment's parameters.
The most important fields are:
- `comment` (a comment that can be used to describe the configuration so that admins can remember why they changed the configuration)
- `non_personalized_probability` (the probability for a participant to be displayed a video which is non-personalized)
- `is_current` (a boolean that marks whether this is the currently active configuration or not - thanks to postgres query indices, the database ensures that only one configuration is active at a time)

The web interface allows to create new configurations and never overrides the previous ones, it just sets the new configuration's `is_current` field to `true` and the previous configuration's `is_current` field to `false`.

When events are stored, the `experiment_config_id` field is populated with the `id` of the configuration that was active at the time of the event so that there is no data loss in case of a configuration update.

### The `session` table

This table represents a browsing session of a participant. It is used to tie events together.
Sessions mirror the concept of the browsers' page sessions as viewed from the point of view of the [sessionStorage](https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage).

A new session is created for each tab opened and ends when a tab is closed.
Duplicating a tab creates a new session.
The end of a session is not explicitly recorded in the database, it seemed unreliable to me but that can probably be added if it is useful.

The primary role of a session is to tie browsing events together.

The most important fields are:
- `uuid` (a unique identifier for the session)
- `participant_code` (the code of the participant to whom the session belongs)

To get the maximum 50 latest sessions from a participant with a given email, you can use a query like:

```sql
select *
from participant p
inner join session s on s.participant_code=p.code
where p.email='bob@example.com'
order by s.id desc
limit 50
```

to get all of them, just remove the `limit` clause.

### The `event` table

This table contains the list of events that have been recorded by the extension.
Each event is tied to a session via the `session_uuid` field.

The most important fields are:
- `session_uuid` (the uuid of the session to which the event belongs)
- `experiment_config_id` (the id of the configuration that was active at the time of the event)
- `arm` (the experiment arm, either `control` or `treatment`, stored on the event in case the participant is re-affected to a different arm later)
- `type` (the type of the event, stored as an enum)

#### How the different events are stored

All events have a `type` field, following is a description of the different types of events and how they are stored.

##### `WATCH_TIME` events

The time spent watching a video, the actual time in seconds is stored in the `watch_time` table with the `event_id` field populated with the id of the event.

To get all the watch times of the latest 15 videos viewed by a given participant you can use a query like:

```sql
select p.email, e.url, e.created_at, w.seconds_watched
from participant p
inner join session s on s.participant_code=p.code
inner join event e on e.session_uuid=s.uuid and e.type='WATCH_TIME'
inner join watch_time w on w.event_id=e.id
where p.email='bob@example.com'
order by e.created_at desc
limit 50
```

##### `MIXED_CLICKED` events

The user clicked on a recommendation that was present in both the personalized and non-personalized recommendations.
The `url` field of the event contains the URL of the video that was clicked on.
The `context` field contains the URL of the page the user was on when the click happened.

##### `NON_PERSONALIZED_CLICKED` events

The user clicked on a recommendation that was only present in the non-personalized recommendations.
The `url` field of the event contains the URL of the video that was clicked on.
The `context` field contains the URL of the page the user was on when the click happened.


##### `PERSONALIZED_CLICKED` events

The user clicked on a recommendation that was only present in the personalized recommendations.
The `url` field of the event contains the URL of the video that was clicked on.
The `context` field contains the URL of the page the user was on when the click happened.

##### `RECOMMENDATIONS_SHOWN` events

The user was shown recommendations, the actual recommendations are stored in the `video_list_item` table with the `event_id` field populated with the id of the event.

To get the latest 50 items from the list of recommendations shown to a given participant you can use a query like:

```sql
select p.email, e.url, e.created_at, v.*, vd.*
from participant p
inner join session s on s.participant_code=p.code
inner join event e on e.session_uuid=s.uuid and e.type='RECOMMENDATIONS_SHOWN'
inner join video_list_item v on v.event_id=e.id
inner join video vd on vd.id = v.video_id
where p.email='bob@example.com'
order by e.created_at desc
limit 50
```

##### `PAGE_VIEW` events

The user visited a page, the URL of the page is stored in the `url` field of the event.
The `context` field represents the previous page the user was on (HTTP referrer).
